"""
Time entries models for NovaTime.

This app handles time tracking, timers, idle detection,
and all time entry-related functionality.
"""

import uuid
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.core.validators import MinValueValidator, MaxValueValidator


class TimeEntry(models.Model):
    """
    TimeEntry model for individual time entries.

    Represents a single time tracking entry with start/end times,
    description, and associations with tasks/projects.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    user = models.ForeignKey(
        'accounts.User',
        on_delete=models.CASCADE,
        related_name='time_entries',
        help_text=_('User who created this time entry')
    )

    workspace = models.ForeignKey(
        'organizations.Workspace',
        on_delete=models.CASCADE,
        related_name='time_entries',
        help_text=_('Workspace this time entry belongs to')
    )

    # Task/Project associations
    task = models.ForeignKey(
        'tasks.Task',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='time_entries',
        help_text=_('Associated task')
    )

    project = models.ForeignKey(
        'tasks.Project',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='time_entries',
        help_text=_('Associated project (if no specific task)')
    )

    # Time tracking
    start_time = models.DateTimeField(
        _('start time'),
        help_text=_('When the time entry started')
    )

    end_time = models.DateTimeField(
        _('end time'),
        null=True,
        blank=True,
        help_text=_('When the time entry ended')
    )

    duration_minutes = models.PositiveIntegerField(
        _('duration (minutes)'),
        default=0,
        help_text=_('Duration in minutes')
    )

    # Description and details
    description = models.TextField(
        _('description'),
        blank=True,
        help_text=_('Description of the work done')
    )

    # Billing and rates
    is_billable = models.BooleanField(
        _('billable'),
        default=True,
        help_text=_('Whether this time entry is billable')
    )

    hourly_rate = models.DecimalField(
        _('hourly rate'),
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text=_('Hourly rate for this entry')
    )

    cost_amount = models.DecimalField(
        _('cost amount'),
        max_digits=12,
        decimal_places=2,
        default=0,
        help_text=_('Calculated cost for this entry')
    )

    # Location and context
    location = models.CharField(
        _('location'),
        max_length=255,
        blank=True,
        help_text=_('Location where work was done')
    )

    ip_address = models.GenericIPAddressField(
        _('IP address'),
        null=True,
        blank=True,
        help_text=_('IP address of the user')
    )

    user_agent = models.TextField(
        _('user agent'),
        blank=True,
        help_text=_('Browser/client user agent')
    )

    # Device and environment
    device_type = models.CharField(
        _('device type'),
        max_length=20,
        choices=[
            ('desktop', 'Desktop'),
            ('laptop', 'Laptop'),
            ('tablet', 'Tablet'),
            ('mobile', 'Mobile'),
            ('other', 'Other'),
        ],
        blank=True,
        help_text=_('Type of device used')
    )

    operating_system = models.CharField(
        _('operating system'),
        max_length=50,
        blank=True,
        help_text=_('Operating system')
    )

    # Productivity and quality
    productivity_score = models.PositiveIntegerField(
        _('productivity score'),
        null=True,
        blank=True,
        validators=[MaxValueValidator(100)],
        help_text=_('AI-calculated productivity score (0-100)')
    )

    focus_score = models.PositiveIntegerField(
        _('focus score'),
        null=True,
        blank=True,
        validators=[MaxValueValidator(100)],
        help_text=_('AI-calculated focus score (0-100)')
    )

    # Idle time tracking
    idle_minutes = models.PositiveIntegerField(
        _('idle minutes'),
        default=0,
        help_text=_('Minutes spent idle during this entry')
    )

    # Tags and categorization
    tags = models.JSONField(
        _('tags'),
        default=list,
        help_text=_('Tags for categorization')
    )

    # Custom fields
    custom_fields = models.JSONField(
        _('custom fields'),
        default=dict,
        help_text=_('Custom fields specific to this entry')
    )

    # AI and automation
    ai_generated = models.BooleanField(
        _('AI generated'),
        default=False,
        help_text=_('Whether this entry was generated by AI')
    )

    ai_confidence = models.DecimalField(
        _('AI confidence'),
        max_digits=3,
        decimal_places=2,
        null=True,
        blank=True,
        validators=[MinValueValidator(0), MaxValueValidator(1)],
        help_text=_('AI confidence score (0-1)')
    )

    # Approval and status
    is_approved = models.BooleanField(
        _('approved'),
        default=None,
        null=True,
        blank=True,
        help_text=_('Approval status (null=pending, true=approved, false=rejected)')
    )

    approved_by = models.ForeignKey(
        'accounts.User',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='approved_time_entries',
        help_text=_('User who approved this entry')
    )

    approved_at = models.DateTimeField(
        _('approved at'),
        null=True,
        blank=True,
        help_text=_('When this entry was approved')
    )

    approval_notes = models.TextField(
        _('approval notes'),
        blank=True,
        help_text=_('Notes from the approver')
    )

    # Metadata
    is_active = models.BooleanField(
        _('active'),
        default=True,
        help_text=_('Whether this time entry is active')
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-start_time']
        verbose_name = _('time entry')
        verbose_name_plural = _('time entries')
        indexes = [
            models.Index(fields=['user', 'start_time']),
            models.Index(fields=['workspace', 'start_time']),
            models.Index(fields=['task', 'start_time']),
            models.Index(fields=['project', 'start_time']),
            models.Index(fields=['start_time', 'end_time']),
            models.Index(fields=['is_billable']),
            models.Index(fields=['is_approved']),
            models.Index(fields=['created_at']),
        ]

    def __str__(self):
        duration = f"{self.duration_minutes}min" if self.duration_minutes else "ongoing"
        task_name = f" - {self.task.title}" if self.task else ""
        return f"{self.user.get_full_name()}: {duration}{task_name}"

    def save(self, *args, **kwargs):
        """Save time entry and calculate derived fields."""
        # Calculate duration if end_time is set
        if self.end_time and self.start_time:
            duration = self.end_time - self.start_time
            self.duration_minutes = int(duration.total_seconds() / 60)

        # Calculate cost if hourly rate is set
        if self.hourly_rate and self.duration_minutes:
            hours = self.duration_minutes / 60
            self.cost_amount = round(self.hourly_rate * hours, 2)

        super().save(*args, **kwargs)

    def get_duration_display(self):
        """Get human-readable duration."""
        if not self.duration_minutes:
            return "0 minutes"

        hours = self.duration_minutes // 60
        minutes = self.duration_minutes % 60

        if hours > 0:
            return f"{hours}h {minutes}m"
        return f"{minutes}m"

    def get_cost_display(self):
        """Get formatted cost display."""
        if not self.cost_amount:
            return "$0.00"
        return ".2f"

    def is_running(self):
        """Check if this time entry is currently running."""
        return self.end_time is None

    def stop(self, end_time=None):
        """Stop the time entry."""
        from django.utils import timezone
        self.end_time = end_time or timezone.now()
        self.save()

    def approve(self, approved_by, notes=''):
        """Approve the time entry."""
        from django.utils import timezone
        self.is_approved = True
        self.approved_by = approved_by
        self.approved_at = timezone.now()
        self.approval_notes = notes
        self.save()

    def reject(self, approved_by, notes=''):
        """Reject the time entry."""
        from django.utils import timezone
        self.is_approved = False
        self.approved_by = approved_by
        self.approved_at = timezone.now()
        self.approval_notes = notes
        self.save()

    def get_overlap_entries(self):
        """Get overlapping time entries for the same user."""
        return TimeEntry.objects.filter(
            user=self.user,
            start_time__lt=self.end_time or self.start_time,
            end_time__gt=self.start_time,
            is_active=True
        ).exclude(pk=self.pk)


class Timer(models.Model):
    """
    Timer model for active time tracking sessions.

    Represents a running timer that can be started, paused, and stopped.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    user = models.ForeignKey(
        'accounts.User',
        on_delete=models.CASCADE,
        related_name='timers',
        help_text=_('User who owns this timer')
    )

    workspace = models.ForeignKey(
        'organizations.Workspace',
        on_delete=models.CASCADE,
        related_name='timers',
        help_text=_('Workspace this timer belongs to')
    )

    # Associated objects
    task = models.ForeignKey(
        'tasks.Task',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='timers',
        help_text=_('Associated task')
    )

    project = models.ForeignKey(
        'tasks.Project',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='timers',
        help_text=_('Associated project')
    )

    # Timer state
    description = models.TextField(
        _('description'),
        blank=True,
        help_text=_('Timer description')
    )

    start_time = models.DateTimeField(
        _('start time'),
        help_text=_('When the timer was started')
    )

    paused_at = models.DateTimeField(
        _('paused at'),
        null=True,
        blank=True,
        help_text=_('When the timer was last paused')
    )

    total_paused_minutes = models.PositiveIntegerField(
        _('total paused minutes'),
        default=0,
        help_text=_('Total minutes spent paused')
    )

    status = models.CharField(
        _('status'),
        max_length=20,
        choices=[
            ('running', 'Running'),
            ('paused', 'Paused'),
            ('stopped', 'Stopped'),
        ],
        default='running',
        help_text=_('Current timer status')
    )

    # Settings
    is_billable = models.BooleanField(
        _('billable'),
        default=True,
        help_text=_('Whether this timer is for billable work')
    )

    hourly_rate = models.DecimalField(
        _('hourly rate'),
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text=_('Hourly rate for this timer')
    )

    # Idle detection
    idle_threshold_minutes = models.PositiveIntegerField(
        _('idle threshold (minutes)'),
        default=5,
        help_text=_('Minutes of inactivity before considering idle')
    )

    auto_stop_on_idle = models.BooleanField(
        _('auto-stop on idle'),
        default=False,
        help_text=_('Whether to automatically stop timer when idle')
    )

    # Location tracking
    track_location = models.BooleanField(
        _('track location'),
        default=False,
        help_text=_('Whether to track location during timing')
    )

    # Metadata
    is_active = models.BooleanField(
        _('active'),
        default=True,
        help_text=_('Whether this timer is active')
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-start_time']
        unique_together = ['user', 'status']  # Only one running timer per user
        verbose_name = _('timer')
        verbose_name_plural = _('timers')
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['workspace', 'status']),
            models.Index(fields=['task']),
            models.Index(fields=['project']),
            models.Index(fields=['start_time']),
            models.Index(fields=['created_at']),
        ]

    def __str__(self):
        duration = self.get_current_duration_display()
        task_name = f" - {self.task.title}" if self.task else ""
        return f"{self.user.get_full_name()}: {duration}{task_name} ({self.status})"

    def get_current_duration_minutes(self):
        """Get current duration in minutes."""
        from django.utils import timezone
        now = timezone.now()

        if self.status == 'stopped':
            return 0

        if self.status == 'paused' and self.paused_at:
            paused_duration = now - self.paused_at
            return int(paused_duration.total_seconds() / 60)

        total_duration = now - self.start_time
        running_minutes = int(total_duration.total_seconds() / 60)
        return running_minutes - self.total_paused_minutes

    def get_current_duration_display(self):
        """Get human-readable current duration."""
        minutes = self.get_current_duration_minutes()
        hours = minutes // 60
        remaining_minutes = minutes % 60

        if hours > 0:
            return f"{hours}h {remaining_minutes}m"
        return f"{remaining_minutes}m"

    def pause(self):
        """Pause the timer."""
        from django.utils import timezone
        if self.status == 'running':
            self.status = 'paused'
            self.paused_at = timezone.now()
            self.save()

    def resume(self):
        """Resume the timer."""
        from django.utils import timezone
        if self.status == 'paused' and self.paused_at:
            paused_duration = timezone.now() - self.paused_at
            self.total_paused_minutes += int(paused_duration.total_seconds() / 60)
            self.status = 'running'
            self.paused_at = None
            self.save()

    def stop(self, end_time=None):
        """Stop the timer and create time entry."""
        from django.utils import timezone

        if self.status in ['running', 'paused']:
            end_time = end_time or timezone.now()

            # Create time entry
            time_entry = TimeEntry.objects.create(
                user=self.user,
                workspace=self.workspace,
                task=self.task,
                project=self.project,
                start_time=self.start_time,
                end_time=end_time,
                duration_minutes=self.get_current_duration_minutes(),
                description=self.description,
                is_billable=self.is_billable,
                hourly_rate=self.hourly_rate,
            )

            # Mark timer as stopped
            self.status = 'stopped'
            self.save()

            return time_entry

        return None

    def is_idle(self):
        """Check if timer is currently idle."""
        # This would integrate with idle detection system
        # For now, return False
        return False


class IdlePeriod(models.Model):
    """
    IdlePeriod model for tracking user inactivity.

    Represents periods of user inactivity during time tracking.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    time_entry = models.ForeignKey(
        TimeEntry,
        on_delete=models.CASCADE,
        related_name='idle_periods',
        help_text=_('Time entry this idle period belongs to')
    )

    start_time = models.DateTimeField(
        _('start time'),
        help_text=_('When the idle period started')
    )

    end_time = models.DateTimeField(
        _('end time'),
        help_text=_('When the idle period ended')
    )

    duration_minutes = models.PositiveIntegerField(
        _('duration (minutes)'),
        help_text=_('Duration of idle period in minutes')
    )

    # Idle detection method
    detection_method = models.CharField(
        _('detection method'),
        max_length=20,
        choices=[
            ('system', 'System Activity'),
            ('mouse_keyboard', 'Mouse/Keyboard'),
            ('application', 'Application Focus'),
            ('manual', 'Manual Report'),
        ],
        default='system',
        help_text=_('Method used to detect idle period')
    )

    # Context
    active_application = models.CharField(
        _('active application'),
        max_length=255,
        blank=True,
        help_text=_('Application that was active during idle period')
    )

    active_window_title = models.CharField(
        _('active window title'),
        max_length=500,
        blank=True,
        help_text=_('Window title that was active during idle period')
    )

    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['start_time']
        verbose_name = _('idle period')
        verbose_name_plural = _('idle periods')
        indexes = [
            models.Index(fields=['time_entry', 'start_time']),
            models.Index(fields=['detection_method']),
            models.Index(fields=['created_at']),
        ]

    def __str__(self):
        return f"Idle: {self.duration_minutes}min during {self.time_entry}"

    def save(self, *args, **kwargs):
        """Save idle period and calculate duration."""
        if self.end_time and self.start_time:
            duration = self.end_time - self.start_time
            self.duration_minutes = int(duration.total_seconds() / 60)

        super().save(*args, **kwargs)


class TimeEntryTemplate(models.Model):
    """
    TimeEntryTemplate model for recurring time entries.

    Represents templates for creating recurring or similar time entries.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    user = models.ForeignKey(
        'accounts.User',
        on_delete=models.CASCADE,
        related_name='time_entry_templates',
        help_text=_('User who owns this template')
    )

    workspace = models.ForeignKey(
        'organizations.Workspace',
        on_delete=models.CASCADE,
        related_name='time_entry_templates',
        help_text=_('Workspace this template belongs to')
    )

    name = models.CharField(
        _('template name'),
        max_length=200,
        help_text=_('Display name for the template')
    )

    description = models.TextField(
        _('description'),
        blank=True,
        help_text=_('Optional description of the template')
    )

    # Template data
    template_data = models.JSONField(
        _('template data'),
        help_text=_('JSON representation of time entry fields to pre-populate')
    )

    # Recurrence settings
    is_recurring = models.BooleanField(
        _('recurring'),
        default=False,
        help_text=_('Whether this template creates recurring entries')
    )

    recurrence_pattern = models.CharField(
        _('recurrence pattern'),
        max_length=50,
        blank=True,
        help_text=_('Recurrence pattern (e.g., daily, weekly, monthly)')
    )

    recurrence_interval = models.PositiveIntegerField(
        _('recurrence interval'),
        default=1,
        help_text=_('Interval for recurrence (e.g., every 2 weeks)')
    )

    # Default values
    default_duration_minutes = models.PositiveIntegerField(
        _('default duration (minutes)'),
        null=True,
        blank=True,
        help_text=_('Default duration for entries created from this template')
    )

    default_is_billable = models.BooleanField(
        _('default billable'),
        default=True,
        help_text=_('Default billable status')
    )

    default_hourly_rate = models.DecimalField(
        _('default hourly rate'),
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text=_('Default hourly rate')
    )

    # Usage tracking
    usage_count = models.PositiveIntegerField(
        _('usage count'),
        default=0,
        help_text=_('Number of times this template has been used')
    )

    # Metadata
    is_active = models.BooleanField(
        _('active'),
        default=True,
        help_text=_('Whether the template is available for use')
    )

    is_public = models.BooleanField(
        _('public'),
        default=False,
        help_text=_('Whether this template is available to all workspace members')
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['user', 'name']
        verbose_name = _('time entry template')
        verbose_name_plural = _('time entry templates')

    def __str__(self):
        return f"{self.user.get_full_name()}: {self.name}"


class TimeEntryComment(models.Model):
    """
    Comment model for time entry discussions.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    time_entry = models.ForeignKey(
        TimeEntry,
        on_delete=models.CASCADE,
        related_name='comments',
        help_text=_('Time entry this comment belongs to')
    )

    author = models.ForeignKey(
        'accounts.User',
        on_delete=models.CASCADE,
        related_name='time_entry_comments',
        help_text=_('User who wrote this comment')
    )

    content = models.TextField(
        _('content'),
        help_text=_('Comment content')
    )

    # Comment type
    comment_type = models.CharField(
        _('comment type'),
        max_length=20,
        choices=[
            ('comment', 'Comment'),
            ('approval', 'Approval'),
            ('rejection', 'Rejection'),
            ('adjustment', 'Adjustment'),
            ('system', 'System Update'),
        ],
        default='comment',
        help_text=_('Type of comment')
    )

    # Visibility
    is_private = models.BooleanField(
        _('private'),
        default=False,
        help_text=_('Whether this comment is private')
    )

    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['created_at']
        verbose_name = _('time entry comment')
        verbose_name_plural = _('time entry comments')

    def __str__(self):
        return f"Comment by {self.author.get_full_name()} on {self.time_entry}"